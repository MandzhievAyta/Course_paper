Grounded Language Learning from Video Described with Sentences  People learn language through exposure to a rich perceptual context. Language is grounded by mapping words, phrases, and sentences to meaning representations referring to the world. Siskind (1996) has shown that even with referential uncertainty and noise, a system based on crosssituational learning can robustly acquire a lexicon, mapping words to word-level meanings from sentences paired with sentence-level meanings. However, it did so only for symbolic representations of word- and sentence-level meanings that were not perceptually grounded. An ideal system would not require detailed word-level labelings to acquire word meanings from video but rather could learn language in a largely unsupervised fashion, just as a child does, from video paired with sentences.

There has been recent research on grounded language learning. Roy (2002) pairs training sentences with vectors of real-valued features extracted from synthesized images which depict 2D blocks-world scenes, to learn a speciﬁc set of features for adjectives, nouns, and adjuncts. Yu and Ballard (2004) paired training images containing multiple objects with spoken name candidates for the objects to ﬁnd the correspondence between lexical items and visual features. Dominey and Boucher (2005) paired narrated sentences with symbolic representations of their meanings, automatically extracted from video, to learn object names, spatial-relation terms, and event names as a mapping from the grammatical structure of a sentence to the semantic structure of the associated meaning representation. Chen and Mooney (2008) learned the language of sportscasting by determining the mapping between game commentaries and the meaning representations output by a rulebased simulation of the game. Kwiatkowski et al.
(2012) present an approach that learns Montaguegrammar representations of word meanings together with a combinatory categorial grammar (CCG) from child-directed sentences paired with ﬁrst-order formulas that represent their meaning.

Although most of these methods succeed in learning word meanings from sentential descriptions they do so only for symbolic or simple visual input (often synthesized); they fail to bridge the gap between language and computer vision, i.e., they do not attempt to extract meaning representations from complex visual scenes. On the other hand, there has been research on training object and event models from large corpora of complex images and video in the computer-vision community (Kuznetsova et al., 2012; Sadanand and Corso, 2012; Kulkarni et al., 2011; Ordonez et al., 2011; Yao et al., 2010). However, most such work requires training data that labels individual concepts with individual words (i.e., ob jects delineated via bounding boxes in images as nouns and events that occur in short video clips as verbs). There is no attempt to model phrasal or sentential meaning, let alone acquire the object or event models from training data labeled with phrasal or sentential annotations. Moreover, such work uses distinct representations for different parts of speech; i.e., object and event recognizers use different representations.

In this paper, we present a method that learns representations for word meanings from short video clips paired with sentences. Our work differs from prior work in three ways. First, our input consists of realistic video ﬁlmed in an outdoor environment. Second, we learn the entire lexicon, including nouns, verbs, prepositions, adjectives, and adverbs, simultaneously from video described with whole sentences. Third we adopt a uniform representation for the meanings of words in all parts of speech, namely Hidden Markov Models (HMMs) whose states and distributions allow for multiple possible interpretations of a word or a sentence in an ambiguous perceptual context.

We employ the following representation to ground the meanings of words, phrases, and sentences in video clips. We ﬁrst run an object detector on each video frame to yield a set of detections, each a subregion of the frame. In principle, the object detector need just detect the objects rather than classify them. In practice, we employ a collection of class-, shape-, pose-, and viewpoint-speciﬁc detectors and pool the detections to account for objects whose shape, pose, and viewpoint may vary over time. Our methods can learn to associate a single noun with detections produced by multiple detectors. We then string together detections from individual frames to yield tracks for objects that temporally span the video clip. We associate a feature vector with each frame (detection) of each such track. This feature vector can encode image features (including the identity of the particular detector that produced that detection) that correlate with object class; region color, shape, and size features that correlate with object properties; and motion features, such as linear and angular object position, velocity, and acceleration, that correlate with event properties. We also compute features between pairs of tracks to encode the relative position and motion of the pairs of objects that participate in events that involve two participants. In principle, we can also compute features  Following Yamoto et al. (1992), Siskind and Morris (1996), and Starner et al. (1998), we represent the meaning of an intransitive verb, like jump, as a two-state HMM over the velocity-direction feature, modeling the requirement that the participant move upward then downward. We represent the meaning of a transitive verb, like pick up, as a two-state HMM over both single-object and object-pair features: the agent moving toward the patient while the patient is as rest, followed by the agent moving together with the patient. We extend this general approach to other parts of speech. Nouns, like person, can be represented as one-state HMMs over image features that correlate with the object classes denoted by those nouns. Adjectives, like red, round, and big, can be represented as one-state HMMs over region color, shape, and size features that correlate with object properties denoted by such adjectives. Adverbs, like quickly, can be represented as one-state HMMs over object-velocity features. Intransitive prepositions, like leftward, can be represented as one-state HMMs over velocity-direction features.
Static transitive prepositions, like to the left of, can be represented as one-state HMMs over the relative position of a pair of objects. Dynamic transitive prepositions, like towards, can be represented as HMMs over the changing distance between a pair of objects. Note that with this formulation, the representation of a verb, like approach, might be the same as a dynamic transitive preposition, like towards. While it might seem like overkill to represent the meanings of words as one-stateHMMs, in practice, we often instead encode such concepts with multiple states to allow for temporal variation in the associated features due to changing pose and viewpoint as well as deal with noise and occlusion. Moreover, the general framework of modeling word meanings as temporally variant time series via multi-state HMMs allows one to model denominalized verbs, i.e., nouns that denote events, as in The jump was fast.

Our HMMs are parameterized with varying arity. Some, like jump(α), person(α), red(α), round(α), big(α), quickly(α), and leftward(α) have one argument, while others, like pick-up(α, β), to-the-left-of(α, β), and towards(α, β), have two arguments (In principle, any arity can be supported.). HMMs are instantiated by mapping their arguments to tracks. This  involves computing the associated feature vector for that HMM over the detections in the tracks chosen to ﬁll its arguments. This is done with a two-step process to support compositional semantics. The meaning of a multi-word phrase or sentence is represented as a joint likelihood of the HMMs for the words in that phrase or sentence. Compositionality is handled by linking or coindexing the arguments of the conjoined HMMs. Thus a sentence like The person to the left of the backpack approached the trashcan would be represented as a conjunction of person(p0), to-the-left-of(p0, p1), backback(p1), approached(p0, p2), and trash-can(p2) over the three participants p0, p1, and p2. This whole sentence is then grounded in a particular video by mapping these participants to particular tracks and instantiating the associated HMMs over those tracks, by computing the feature vectors for each HMM from the tracks chosen to ﬁll its arguments.

Our algorithm makes six assumptions. First, we assume that we know the part of speech Cm associated with each lexical entry m, along with the part-of-speech dependent number of states Ic in the HMMs used to represent word meanings in that part of speech, the part-of-speech dependent number of features Nc in the feature vectors used by HMMs to represent word meanings in that part of speech, and the part-of-speech dependent feature-vector computation Φc used to compute the features used by HMMs to represent word meanings in that part of speech. Second, we pair individual sentences each with a short video clip that depicts that sentence. The algorithm is not able to determine the alignment between multiple sentences and longer video segments. Note that there is no requirement that the video depict only that sentence. Other objects may be present and other events may occur. In fact, nothing precludes a training corpus with multiple copies of the same video, each paired with a different sentence describing a different aspect of that video.
Moreover, our algorithm potentially can handle a small amount of noise, where a video clip is paired with an incorrect sentence that the video does not depict. Third, we assume that we already have (pre-trained) low-level object detectors capable of detecting instances of our target event participants in individual frames of the video. We allow such detections to be unreliable; our method can handle a moderate amount of false positives  and false negatives. We do not need to know the mapping from these object-detection classes to words; our algorithm determines that. Fourth, we assume that we know the arity of each word in the corpus, i.e., the number of arguments that that word takes. For example, we assume that we know that the word person(α) takes one argument and the word approached(α, β) takes two arguments. Fifth, we assume that we know the total number of distinct participants that collectively ﬁll all of the arguments for all of the words in each training sentence. For example, for the sentence The person to the left of the backpack approached the trash-can, we assume that we know that there are three distinct objects that participate in the event denoted. Sixth, we assume that we know the argument-to-participant mapping for each training sentence. Thus, for example, for the above sentence we would know person(p0), to-the-left-of(p0, p1), backback(p1), approached(p0, p2), and trash-can(p2). The latter two items can be determined by parsing the sentence, which is what we do. One can imagine learning the ability to automatically perform the latter two items, and even the fourth item above, by learning the grammar and the part of speech of each word, such as done by Kwiatkowski et al.
(2012). We leave such for future work.

Figure 1 illustrates a single frame from a potential training sample provided as input to our learner. It consists of a video clip paired with a sentence, where the arguments of the words in the sentence are mapped to participants. From a sequence of such training samples, our learner determines the objects tracks and the mapping from participants to those tracks, together with the meanings of the words.

The remainder of the paper is organized as follows. Section 2 generally describes our problem of lexical acquisition from video. Section 3 introduces our work on the sentence tracker, a method for jointly tracking the motion of multiple objects in a video that participate in a sententiallyspeciﬁed event. Section 4 elaborates on the details of our problem formulation in the context of this sentence tracker. Section 5 describes how to generalize and extend the sentence tracker so that it can be used to support lexical acquisition. We demonstrate this lexical acquisition algorithm on a small example in Section 6. Finally, we conclude with a discussion in Section 7.

The person to the left of the backpack carried the trash-can towards the chair.
α α β α α β α α β α p0 p0 p1 p1 p0 p2 p2 p0 p3 p3  Throughout this paper, lowercase letters are used for variables or hidden quantities while uppercase ones are used for constants or observed quantities.
We are given a lexicon {1, . . . , M }, letting m denote a lexical entry. We are given a sequence D = (D1, . . . , DR) of video clips Dr, each paired with a sentence Sr from a sequence S = (S1, . . . , SR) of sentences. We refer to Dr paired with Sr as a training sample. Each sentence Sr is a sequence (Sr,1, . . . , Sr,Lr ) of words Sr,l, each an entry from the lexicon. A given entry may potentially appear in multiple sentences and even multiple times in a given sentence. For example, the third word in the ﬁrst sentence might be the same entry as the second word in the fourth sentence, in which case S1,3 = S4,2. This is what allows cross-situational learning in our algorithm.
Let us assume, for a moment, that we can process each video clip Dr to yield a sequence (τr,1, . . . , τr,Ur ) of object tracks τr,u. Let us also assume that Dr is paired with a sen tence Sr = The person approached the chair, speciﬁed to have two participants, pr,0 and pr,1, with the mapping person(pr,0), chair(pr,1), and approached(pr,0, pr,1). Let us further assume, for a moment, that we are given a mapping from participants to object tracks, say pr,0 7→ τr,39 and pr,1 7→ τr,51. This would allow us to instantiate the HMMs with object tracks for a given video clip: person(τr,39), chair(τr,51), and approached(τr,39, τr,51). Let us further assume that we can score each such instantiated HMM and aggregate the scores for all of the words in a sentence to yield a sentence score and further aggregate the scores for all of the sentences in the corpus to yield a corpus score. However, we don’t know the parameters of the HMMs. These constitute the unknown meanings of the words in our corpus which we wish to learn. The problem is to simultaneously determine (a) those parameters along with (b) the object tracks and (c) the mapping from participants to object tracks. We do this by ﬁnding (a)–(c) that maximizes the corpus score.

Barbu et al. (2012a) presented a method that ﬁrst determines object tracks from a single video clip and then uses these xﬁed tracks with HMMs to recognize actions corresponding to verbs and construct sentential descriptions with templates. Later Barbu et al. (2012b) addressed the problem of solving (b) and (c), for a single object track constrained by a single intransitive verb, without solving (a), in the context of a single video clip. Our group has generalized this work to yield an algorithm called the sentence tracker which operates by way of a factorial HMM framework. We introduce that here as the foundation of our extension.
Each video clip Dr contains Tr frames. We run an object detector on each frame to yield a set Drt of detections. Since our object detector is unreliable, we bias it to have high recall but low precision, yielding multiple detections in each frame. We form an object track by selecting a single detection for that track for each frame. For a moment, let us consider a single video clip with length T , with detections Dt in frame t. Further, let us assume that we seek a single object track in that video clip. Let jt denote the index of the detection from Dt in frame t that is selected to form the track. The object detector scores each detection. Let F (Dt, jt) denote that score. More over, we wish the track to be temporally coherent; we want the objects in a track to move smoothly over time and not jump around the ﬁeld of view.
Let G(Dt−1, jt−1, Dt, jt) denote some measure of coherence between two detections in adjacent frames. (One possible such measure is consistency of the displacement of Dt relative to Dt−1 with the velocity of Dt−1 computed from the image by optical ﬂow.) One can select the detections to yield a track that maximizes both the aggregate detection score and the aggregate temporal coherence score.

This can be determined with the Viterbi (1967) algorithm and is known as detection-based tracking (Viterbi, 1971).
Recall that we model the meaning of an intransitive verb as an HMM over a time series of features extracted for its participant in each frame. Let λ denote the parameters of this HMM, (q1, . . . , qT ) denote the sequence of states qt that leads to an observed track, B(Dt, jt, qt, λ) denote the conditional log probability of observing the feature vector associated with the detection selected by jt among the detections Dt in frame t, given that the HMM is in state qt, and A(qt−1, qt, λ) denote the log transition probability of the HMM. For a given track (j1, . . . , jT ), the state sequence that yields the maximal likelihood is given by:  which can also be found by the Viterbi algorithm.
A given video clip may depict multiple objects, each moving along its own trajectory. There may be both a person jumping and a ball rolling. How are we to select one track over the other? The key insight of the sentence tracker is to bias the selection of a track so that it matches an HMM. This is done by combining the cost function of Eq. 1 with the cost function of Eq. 2 to yield Eq. 3, which can also be determined using the Viterbi algorithm.
This is done by forming the cross product of the  two lattices. This jointly selects the optimal detections to form the track, together with the optimal state sequence, and scores that combination.

 T  X F (Dt, jt) max  t=1T+ B(Dt, jt, qt, λ)  (3) qj11,,......,,jqTT  + X G(Dt−1, jt−1, Dt, jt)   While we formulated the above around a single track and a word that contains a single participant, it is straightforward to extend this so that it supports multiple tracks and words of higher arity by forming a larger cross product. When doing so, we generalize jt to denote a sequence of detections from Dt, one for each of the tracks. We further need to generalize F so that it computes the joint score of a sequence of detections, one for each track, G so that it computes the joint measure of coherence between a sequence of pairs of detections in two adjacent frames, and B so that it computes the joint conditional log probability of observing the feature vectors associated with the sequence of detections selected by jt. When doing this, note that Eqs. 1 and 3 maximize over j1, . . . , jT which denotes T sequences of detection indices, rather than T individual indices.
It is further straightforward to extend the above to support a sequence (S1, . . . , SL) of words Sl denoting a sentence, each of which applies to different subsets of the multiple tracks, again by forming a larger cross product. When doing so, we generalize qt to denote a sequence (q1t, . . . , qLt) of states qlt, one for each word l in the sentence, and use ql to denote the sequence (ql1, . . . , qlT ) and q to denote the sequence (q1, . . . , qL). We further need to generalize B so that it computes the joint conditional log probability of observing the feature vectors for the detections in the tracks that are assigned to the arguments of the HMM for each word in the sentence and A so that it computes the joint log transition probability for the HMMs for all words in the sentence. This allows selection of an optimal sequence of tracks that yields the highest score for the sentential meaning of a sequence of words. Modeling the meaning of a sentence through a sequence of words whose meanings are modeled by HMMs, deﬁnes a factorial HMM for that sentence, since the overall Markov process for that sentence can be factored into inde pendent component processes (Brand et al., 1997; Zhong and Ghosh, 2001) for the individual words.
In this view, q denotes the state sequence for the combined factorial HMM and ql denotes the factor of that state sequence for word l. The remainder of this paper wraps this sentence tracker in Baum Welch (Baum et al., 1970; Baum, 1972).

We adapt the sentence tracker to training a corpus of R video clips, each paired with a sentence.
Thus we augment our notation, generalizing jt to jrt and qlt to qrt,l. Below, we use jr to denote (jr1, . . . , jrTr ), j to denote (j1, . . . , jR), qr,l to denote (qr1,l, . . . , qrT,rl ), qr to denote (qr,1, . . . , qr,Lr ), and q to denote (q1, . . . , qR).
We use discrete features, namely natural numbers, in our feature vectors, quantized by a binning process. We assume the part of speech of entry m is known as Cm. The length of the feature vector may vary across parts of speech. Let Nc denote the length of the feature vector for part of speech c, xr,l denote the time-series (xr1,l, . . . , xrT,rl ) of feature vectors xtr,l, associated with Sr,l (which recall is some entry m), and xr denote the sequence (xr,1, . . . , xr,Lr ). We assume that we are given a function Φc(Drt, jrt) that computes the feature vector xtr,l for the word Sr,l whose part of speech is CSr,l = c. Note that we allow Φ to be dependent on c allowing different features to be computed for different parts of speech, since we can determine m and thus Cm from Sr,l. We choose to have Nc and Φc depend on the part of speech c and not on the entry m since doing so would be tantamount to encoding the to-be-learned word meaning in the provided feature-vector computation.
The goal of training is to ﬁnd a sequence λ = (λ1, . . . , λM ) of parameters λm that best explains the R training samples. The parameters λm constitute the meaning of the entry m in the lexicon.
Collectively, these are the initial state probabilities a0m,k, for 1 ≤ k ≤ ICm , the transition probabilities aim,k, for 1 ≤ i, k ≤ ICm , and the output probabilities bim,n(x), for 1 ≤ i ≤ ICm and 1 ≤ n ≤ NCm , where ICm denotes the number of states in the HMM for entry m. Like before, we could have a distinct Im for each entry m but instead have ICm depend only on the part of speech of entry m, and assume that we know the ﬁxed I for each part of speech. In our case, bim,n is a discrete distribution because the features are binned.

Instantiating the above approach requires a deﬁnition for what it means to best explain the R training samples. Towards this end, we deﬁne the score of a video clip Dr paired with sentence Sr given the parameter set λ to characterize how well this training sample is explained. While the cost function in Eq. 3 may qualify as a score, it is easier to ﬁt a likelihood calculation into the Baum-Welch framework than a MAP estimate. Thus we replace the max in Eq. 3 with a P and redeﬁne our scoring function as follows:  The score in Eq. 4 can be interpreted as an expectation of the HMM likelihood over all possible mappings from participants to all possible tracks.
By deﬁnition, P (jr|Dr) = PjVr0(VD(rD,jrr,)jr0) , where the numerator is the score of a particular track sequence jr while the denominator sums the scores over all possible track sequences. The log of the numerator V (Dr, jr) is simply Eq. 1 without the max. The log of the denominator can be computed efﬁciently by the forward algorithm (Baum and Petrie, 1966). The likelihood for a factorial HMM can be computed as:  i.e., summing the likelihoods for all possible state sequences. Each summand is simply the joint likelihood for all the words in the sentence conditioned on a state sequence qr. For HMMs we have  Finally, for a training corpus of R samples, we seek to maximize the joint score:  A local maximum can be found by employing the Baum-Welch algorithm (Baum et al., 1970; Baum, 1972). By constructing an auxiliary function (Bilmes, 1997), one can derive the reestimat tion formulas in Eq. 8, where xr,l,n = h denotes the selection of all possible jrt such that the nth  feature computed by ΦCm (Drt, jrt) is h. The coefﬁcients θim and ψim,n are for normalization.
The reestimation formulas involve occurrence counting. However, since we use a factorial HMM that involves a cross-product lattice and use a scoring function derived from Eq. 3 that incorporates both tracking (Eq. 1) and word models (Eq. 2), we need to count the frequency of transitions in the whole cross-product lattice. As an example of such cross-product occurrence counting, when counting the transitions from state i to k for the lth word from frame t − 1 to t, i.e., ξ(r, l, i, k, t), we need to count all the possible paths through the adjacent factorial states (jrt−1, qrt−,11, . . . , qrt−,L1r )  and (jrt, qrt,1, . . . , qrt,Lr ) such that qt−1 = i and r,l qrt,l = k. Similarly, when counting the frequency of being at state i while observing h as the nth feature in frame t for the lth word of entry m, i.e., γ(r, l, n, i, h, t), we need to count all the possible paths through the factorial state (jrt, qrt,1, . . . , qrt,Lr ) such that qrt,l = i and the nth feature computed by ΦCm (Drt, jrt) is h.
The reestimation of a single component HMM can depend on the previous estimate for other component HMMs. This dependence happens because of the argument-to-participant mapping which coindexes arguments of different component HMMs to the same track. It is precisely this dependence that leads to cross-situational learning of two kinds: both inter-sentential and intra-sentential. Acquisition of a word meaning is driven across sentences by entries that appear in more than one training sample and within sentences by the requirement that the meanings of all of the individual words in a sentence be consistent with the collective sentential meaning.

We ﬁlmed 61 video clips (each 3–5 seconds at 640×480 resolution and 40 fps) that depict a variety of different compound events. Each clip depicts multiple simultaneous events between some  S → NP VP NP → D N [PP] D → the N → person | backpack | trash-can | chair PP → P NP P → to the left of | to the right of VP → V NP [ADV] [PPM] V → picked up | put down | carried | approached ADV → quickly | slowly PPM → PM NP PM → towards | away from  subset of four objects: a person, a backpack, a chair, and a trash-can. These clips were ﬁlmed in three different outdoor environments which we use for cross validation. We manually annotated each video with several sentences that describe what occurs in that video. The sentences were constrained to conform to the grammar in Table 1.
Our corpus of 159 training samples pairs some videos with more than one sentence and some sentences with more than one video, with an average of 2.6 sentences per video 1.
We model and learn the semantics of all words except determiners. Table 2 speciﬁes the arity, the state number Ic, and the features computed by Φc for the semantic models for words of each part of speech c. While we specify a different subset of features for each part of speech, we presume that, in principle, with enough training data, we could include all features in all parts of speech and automatically learn which ones are noninformative and lead to uniform distributions.
We use an off-the-shelf object detector (Felzenszwalb et al., 2010a; Felzenszwalb et al., 2010b) which outputs detections in the form of scored axis-aligned rectangles. We trained four object detectors, one for each of the four object classes in  1Our code, videos, and sentential annotations are available at http://haonanyu.com/research/ acl2013/.

our corpus: person, backpack, chair, and trashcan. For each frame, we pick the two highestscoring detections produced by each object detector and pool the results yielding eight detections per frame. Having a larger pool of detections per frame can better compensate for false negatives in the object detection and potentially yield smoother tracks but it increases the size of the lattice and the concomitant running time and does not lead to appreciably better performance on our corpus.
We compute continuous features, such as velocity, distance, size ratio, and x-position solely from the detection rectangles and quantize the features into bins as follows: velocity To reduce noise, we compute the velocity of a participant by averaging the optical ﬂow in the detection rectangle. The velocity magnitude is quantized into 5 levels: absolutely stationary, stationary, moving, fast moving, and quickly.
The velocity orientation is quantized into 4 directions: left, up, right, and down.
distance We compute the Euclidean distance between the detection centers of two participants, which is quantized into 3 levels: near, normal, and far away.
size ratio We compute the ratio of detection area of the ﬁrst participant to the detection area of the second participant, quantized into 2 possibilities: larger/smaller than.
x-position We compute the difference between the x-coordinates of the participants, quantized into 2 possibilities: to the left/right of.
The binning process was determined by a preprocessing step that clustered a subset of the training data. We also incorporate the index of the detector that produced the detection as a feature. The par ticular features computed for each part of speech are given in Table 2.
Note that while we use English phrases, like to the left of, to refer to particular bins of particular features, and we have object detectors which we train on samples of a particular object class such as backpack, such phrases are only mnemonic of the clustering and object-detector training process.
We do not have a ﬁxed correspondence between the lexical entries and any particular feature value.
Moreover, that correspondence need not be oneto-one: a given lexical entry may correspond to a (time variant) constellation of feature values and any given feature value may participate in the meaning of multiple lexical entries.
We perform a three-fold cross validation, taking the test data for each fold to be the videos ﬁlmed in a given outdoor environment and the training data for that fold to be all training samples that contain other videos. For testing, we hand selected 24 sentences generated by the grammar in Table 1, where each sentence is true for at least one test video.
Half of these sentences (designated NV) contain only nouns and verbs while the other half (designated ALL) contain other parts of speech. The latter are longer and more complicated than the former. We score each testing video paired with every sentence in both NV and ALL. To evaluate our results, we manually annotated the correctness of each such pair.
Video-sentence pairs could be scored with Eq. 4. However, the score depends on the sentence length, the collective numbers of states and features in the HMMs for words in that sentence, and the length of the video clip. To render the scores comparable across such variation we incorporate a sentence prior to the per-frame score: 1 Lˆ(Dr, Sr; λ) = [L(Dr; Sr, λ)] Tr π(Sr) (9)  n=1 In the above, ZCSr,l ,n is the number of bins for the nth feature of Sr,l of part of speech CSr,l and E(Y ) = − PY y=1 Y1 log Y1 = log Y is the entropy of a uniform distribution over Y bins. This prior prefers longer sentences which describe more information in the video.

The scores are thresholded to decide hits, which together with the manual annotations, can generate TP, TN, FP, and FN counts. We select the threshold that leads to the maximal F1 score on the training set, use this threshold to compute F1 scores on the test set in each fold, and average F1 scores across the folds.

The F1 scores are listed in the column labeled Our in Table 3. For comparison, we also report F1 scores for three baselines: Chance, Blind, and Hand. The Chance baseline randomly classiﬁes a video-sentence pair as a hit with probability 0.5.
The Blind baseline determines hits by potentially looking at the sentence but never looking at the video. We can ﬁnd an upper bound on the F1 score that any blind method could have on each of our test sets by solving a 0-1 fractional programming problem (Dinkelbach, 1967) (see Appendix A for details). The Hand baseline determines hits with hand-coded HMMs, carefully designed to yield what we believe is near-optimal performance. As can be seen from Table 3, our trained models perform substantially better than the Chance and Blind baselines and approach the performance of the ideal Hand baseline. One can further see from the ROC curves in Figure 2, comparing the trained and hand-written models on both NV and ALL, that the trained models are close to optimal. Note that performance on ALL exceeds that on NV with the trained models. This is because longer sentences with varied parts of speech incorporate more information into the scoring process.

7 Conclusion We presented a method that learns word meanings from video paired with sentences. Unlike prior work, our method deals with realistic video scenes labeled with whole sentences, not individual words labeling hand delineated objects or events. The experiment shows that it can correctly learn the meaning representations in terms of HMM parameters for our lexical entries, from highly ambiguous training data. Our maximumlikelihood method makes use of only positive sentential labels. As such, it might require more training data for convergence than a method that also makes use of negative training sentences that are not true of a given video. Such can be handled with discriminative training, a topic we plan to address in the future. We believe that this will allow learning larger lexicons from more complex video without excessive amounts of training data.

Acknowledgments This research was sponsored by the Army Research Laboratory and was accomplished under Cooperative Agreement Number W911NF-10-20060. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the ofﬁcial policies, either express or implied, of the Army Research Laboratory or the U.S. Government. The U.S.
Government is authorized to reproduce and distribute reprints for Government purposes, notwithstanding any copyright notation herein.

A Blind algorithm makes identical decisions on the same sentence paired with different video clips. An optimal algorithm will try to ﬁnd a decision si for each test sentence i that maximizes the F1 score. Suppose, the ground-truth yields FPi false positives and TPi true positives on the test set when si = 1. Also suppose that setting si = 0 yields FNi false negatives. Then the F1 score is  Thus we want to minimize the term Δ. This is an instance of a 0-1 fractional programming problem which can be solved by binary search or Dinkelbach’s algorithm (Dinkelbach, 1967).