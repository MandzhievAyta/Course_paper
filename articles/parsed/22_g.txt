There is no need to show the importance of arcconsistency in Constraint Networks. Originating from Waltz [Waltz72], who developed it for vision problems, it has been studied by Mackworth and Freuder [Mackworth77], [Mac&Fre85], by Mohr and Henderson [Moh&Hen86] who have proposed an algorithm having an optimal worst-case time complexity: O(ed2 ), where e is the number of constraints (or relations) and d the size of the largest domain. In [Bessiere91] its use has been extended to Dynamic constraint networks. Recently, Van Hentenryck, Deville and Teng [Dev&VanH91], [VanH&al92], have proposed a generic algorithm which can be implemented with all known techniques, and have extracted classes of networks on which there exist algorithms running arcconsistency in O(ed). In 1992, Perlin [Perlin92] has  g” ven properties of arc-consistency on factorable relations.
Everybody now looks for arc-consistency complexity in particular classes of constraint networks because AC-4 [Moh&Hen86] has an optimal worst-case complexity and it is supposed that we cannot do better.
But AC-4 drawbacks are its average time complexity which is too much near the worst-case time complexity and more, its space complexity which is O(ed2). In applications with a large number of values in variables domains and with weak constraints, AC-3 is often used instead of AC-4 because of its space complexity. Such situations appear for example when domains encode discrete intervals and constraints are defined as arithmetic relations (2, <, f,... ). Constraint Logic Programming (CLP) languages [Din&a1881 which are big consumers of arc-consistency (arc-consistency has some good properties in CLP) are concerned by these problems.
In problems with many solutions, where the constraints are weak, AC-4 initialization step is very long because it requires to consider the relations in their whole to construct its data structure. In those cases, AC-3 [Mac&Fre85] runs faster than AC-4 in spite of its non-optimal time complexity.
In this paper we propose a new algorithm, AC-6, which while keeping O(ed2) optimal worst-case time complexity of AC-4, discards the problem of space complexity (AC-6 space complexity is O(ed)) and checks just enough data in the constraints to compute the arc-consistent domain. AC-4 looks for all the reasons for a value to be in the arc-consistent domain: it checks, for each value, all the values compatible with it (called its supports) to prove this value is viable. AC-6 only looks for one reason per constraint to prove that a value is viable: it checks, for each value, one support per constraint, looking for another one only when the current support is removed from the domain.
The rest of the paper is organized as follows.
Section 2 gives some preliminaries on constraint networks and arc-consistency. Section 3 presents the algorithm AC-6. In section 4, experimental results  show how much AC-6 outperforms the algorithms AC-3 and AC-4l. A conclusion is given in section 5.

A network of binary constraints (CN) is defined as a set of n variables {i, j,. . .], a domain D=]Di, Dj,. ..I where Di is the set of possible values for variable i, and a set of binary constraints between variables. A binary constraint (or relation) Xij between variables i and j is a subset of the Cartesian product Di x D j that specifies the allowed pairs of values for i and j.
Following from Montanari [Montanari74], a binary relation Xi* between variables i and j is usually represente d as a (O,l)-matrix (or a matrix of booleans) with IDi I rows and I Dj I CO~UIIUISby imposing an ordering on the domains of the variables. Value true at row a, column b, denoted Rii<a, b), means that the pair consisting of the ath element of Di and the bth element of D * is permitted; value false means the pair is not permi cted. In all the networks of interest here Xij(a, b>=Rji(b, a). In some applications (constraint logic programming, temporal reasoning,. . .), Rij is defined as an arithmetic relation (=, #, <, 2,. . .) without giving the matrix of allowed and not allowed pairs of values.
A graph G can be associated to a constraint network, where nodes correspond to variables in the CN and an edge links nodes i and j every time there is a relation Rij on variables i and j in the CN. For the purpose of this paper, we consider G as a symetric directed graph with arcs (i, j) and (j, i) in place of the edge {i, j}.
A solution of a constraint network is an instantiation of the variables such that all the constraints are satisfied.

Definition. Having the constraint Xi*, value b in Dj is called a support for value a in d i if the pair (a, b) is allowed by Rij (i.e. Rij(a, b) is true).
A value a for a variable i IS viable if for every variable j such that Rij exists, a has a support in D*.
d e domain D of a CN is arc-consistent if for every variable i in the CN, all the values in Di are viable.

and Henderson underlined in [Moh&arc-consistency is based on the notion As long as a value a for a variable i (denoted  IAC-5 [VanH&al92] is not discussed improvement but a generic framework algorithms can be written.

(i, a)) has supporting values on each of the other variables j linked to i in the constraint graph, a is considered a viable value for i. But once there exists a variable on which no remaining value satisfies the relation with (i, a), then a must be eliminated from Di.
The algorithm proposed in [Moh&Hen86] makes this support explicit by assigning a counter counter[(i, j), a] to each arc-value pair involving the arc (i, j) and the value a on the variable i. This counter records the number of supports of (i, a) in Dj.
For each value (j, b), a set S ‘b is constructed, where sjb={(i, a)/(j, b) supports (i, aJ}. Then, if (j, b) is eliminated from Dj, counter[(i, j), a] must be decremented for each (i, a) III Sjb.
This data structure is at the origin of AC-4 optimal worst-case time complexity. But computing the number of supports for each value (i, a) on each constraint Rij and recording all the values (i, a) supported by each value Jj, b) implies an expensive space complexity of O(ed-) (the size of the support sets Sjb) and an average time complexity increasing with the number of allowed pairs in the relations since the number of supports is proportional to the number of allowed pairs in the relations.
The purpose of AC-6 is then to avoid the expensive checking of the relations to find all the supports for all the values. AC-6 keeps the same principle as AC-4, but instead of checking all the supports for a value, it only checks one support (the first one) for each value (i, a) on each constraint Ri* to prove that (i, a) is currently viable. When (j, br’ is found as the smallest support of (i, a) on Rij, (i, a) is added to Sjb, the list of values currently having (j, b) as smallest support. If (j, b) is removed from Dj then AC-6 looks for the next support in Dj for each value (i, a) in Sjb. The only requirement in the use of AC-6 is to have a total ordering in all domains Dj. But this is not a restriction since in any implementation, a total ordering is imposed on the domains. This ordering is independent of any ordering computed in a rearrangement strategy for searching solutions.

The algorithm proposed here works with the following data structure: e A table M of booleans keeps track of which values of the initial domain are in the current domain or not (M(i, a)=true H aE Di). In this table, each initial Di is considered as the integer range I.. 1Di ] . But it can be a set of values of any type with a total ordering on these values. We use the following  constant time functions to handle Di sets that are considered as lists: -first(Q ) returns the smallest value in Q.
- last(Q ) returns the largest value in Q.
- next(u, Di ) returns the value a’ in Di such that every value a Dlarger than a and smaller than a ’ is out of Di.
0 Sjb=I(i, a>/& b) is the smallest value in D j supporting (i, a) on Xii) while in AC-4 it was containing all the values supported by (j, b).
0 Counters for each arc-value pair in AC-4 are not used in AC-6.
e A list List contains values deleted from the domain but for which the propagation of the deletion has not been processed yet.
In AC-4, when a value (j, b) was deleted, it was added to List waiting for the propagation of the consequences of its deletion. These consequences were to decrement counfer[(i, j), a] for every (i, a) in Sjb and to delete (i, a) when counfer[(i, j), a] becomes equal to zero. In AC-6, the use of List is not changed but the consequence of (j, 6) deletion is now to find another support for every (i, a) in S-b. Having an ordering on Dj we look after b (the o I!d support) for another value c in Dj supporting (i, a) on Xij (we know there is no such value before b). When such a value c is found, (i, a) is added to Sjc since (j, c) is the new smallest support for (i, a) in Dj. If no such value exists, (i, a) is removed and put in List.
AC-6 uses the following procedure to find the smallest value in Dj not smaller than b and supporting (i, a) on Rij:  i, j, a : integer; in out b : integer; out emptysupport : boolean);  {search of the smallest value as large as b that belongs to Dj; this part is not needed in the call of the procedure done in the initialization step since b already belongs to Dj } while not M(j, b) and b c last(Dj ) do b t b + 1 ; emptysupport t not M(j, b) ;  {search of the smallest support for (i, a) in Dj} while not R$a, b) and not emptysuppoftdo if b c last(Dj) then b t next(b, Dj) else emptysupport t true  The algorithm AC-6 has the same framework as AC-4. In the initialization step, we look for a support for every value (i, a) on each constraint Rq to prove that (i, a) is viable. If there exists a constraint Rij on which (i, a) has no support, it is removed from Di and put in List.
In the propagation step, values (j, b) are taken from List to propagate the consequences of their deletion: finding another support (j, c) for values (i, a)  they were supporting (values (i, a) in Sjb). When such a value c in Di is not found, (i, a) is removed from Di and put in Lid at its turn.

{initialization} for(i, a) E Ddo &t0; M(i, a)+ true; for ((1) E arcs(GJ do foraE Did0 begin if Dj= 0 then emptysupport t true else b t first(Dj) ; nextsupport(i, if emptysuppott then Di t Di\ {a} ; M(i, a) t false ; Append( List, (i, a)) else Append(Sjb, (i, a)) end  {propagation} while List # 0 do begin choose (j, b) from List and remove (j, b) from List; for (i, a) E sjb do {before its deletion (j, b) was the begin smallest support in Djfor (i, a) on Rii} remove (i, a) from sjb ; if M(i, a) then begin c t b ; nextsupport(i, j, a, c, emptysupport) ; if emptysupport then Di t Di\ {a} ; M(i, a) t false ; Append( List, (i, a)) i:; Append(Sjc, (i, a))  3.3. Correctness of AC-6 Here are the key steps for a complete proof of the correcmess of AC-6. In this section we denote maxAC the maximal arc-consistent domain which is expected to be computed by an arc-consistency algorithm.
0 In AC-6, value (i, a) is removed from Di only when it has no support in Dj on a constraint Ri*. If all previously removed values are out of maxA 6 then (i, a) is out of maxAC. maxAC was trivially included in D when AC-6 started. Then, by induction, (i, a) is out of maxAC. Thus, maxAC CD is an invariant property of AC-6.
* Every time a value 0, b) is removed, it is put in List until the values it was supporting are checked for new supports. Every time a value (i, a) is found without support on a constraint, it is removed from D. Thus, every value (i, a) in D has at least one support in DuLisf on each constraint Rij. AC-6 terminates with List empty. Hence, after AC-6, every  orresponding to a house position (e.g. assigning the value 2 to the variable horse means that the horse owner lives in the second house) [Dechter88].