The Tractability of Subsumption in Frame-Based Description Languages  Laboratory for Artificial Intelligence 4001 Miranda Avenue Palo Alto, California 94304  Among the more popular representation languages in use today are those based on the notion of frames (see, for example, [l], (31, and 191).
Frames give us the ability to define structured types; typically a frame comprises a set of more general frames (its super/rames) as well as a set of descriptions of the attributes (slots) of instances of the frame.
The most common type of slot description specifies a restriction on the value of the filler of the slot for all instances of the frame. The restriction can be as specific as a particular value that all instances of the frame must exhibit (alternatively, the value may be just a de/auf& in which case an individual inherits the value provided he does not override it). or it mav be a more neneral constraint on attribute values,  in which case this value restriction is usually a pointer to another frame. Less commonly, the number of required fillers is also specified in a slot restriction (often in terms of a minimum and a maximum number of attribute values). 1 The generalization relation between frame and superframe, or between two frames where one is simply more restricted version of another, implicitly forms a tozonomy, inheritance Aierorchy.

Notationally, a frame might be defined by a list of superframes (with either an explicit or implicit “isa” relation [Z]), followed by a set of slot restrictions expressed by attribute/value-description pairs (with attribute and value-description usually separated by a colon).
For example, the simple frame  is intended to be a struct,ured type representing the concept of a person that has at least one child, and all of whose sons (i.e., male children) are lawyers and all of whose daughters are doctors. Similarly, the more complicated frame,  [STUDENT, FEMALE department: COMPUTER-SCIENCE enrolled-course (2 3) : [GRADUATE-COURSE department:  is intended to be a structured type that describes female Computer Science students taking at least three graduate courses in a department within a school of Engineering.’  There is a natural correspondence between this frame form of description and noun phrases in natural language. For example, the above frame might just as well have been written as “student and a female whose department is computer-science, and who has at least 3 enrolled-courses, each of which is a graduate-course whose department is an engineering-department.” A simple set of translation rules would allow us to move easily from frame form to (almost) readable English.’  ‘While the use of number restrictions is not widespread, they have been used extensively in KL-ONE (S] and Ianguages Iike it 141. They seem to be a useful generalization of the existential reading of slots (see below), so we include them here.

2Typically, frames are given nomu as well; for example, we might have labeled our first example frame, “PROUD-PARENTW”e. have explicitIy chosen to avoid these here so as to eliminate confusion about their meanings. For this paper, we are interested in relations among frames implied by their rlrcrctweonly (see below), and will assume that atoms are all independent.
aFor example, the list of superframes would translate into a conjunction of nouns (“otudent and a female”). A slot that had only one filler might translate into a simple “whose” clause (‘whose deDutmmt is computer rciencr”). And a slot  One interesting property of these structured types is that we do not have to state explicitly when one of them is below another in the taxonomy. The descriptions themselves implicitly define a taxonomy of subsumption, where type A subsumes type B if, by virtue of the form of A and B, every instance of B must be an instance of A. In other words, it can be determined that being an A is implicit in being a B, based only on the structure of the two terms (no “user” needs to make an explicit statement of this relationship). For example, without any world knowledge, we can determine that the type “person” subsumes the type  Similarly, “person who has at least 2 children” who has at least 3 male children”.

The computation of analytic relations like subsumption (and others, such as difijointnesesee 141) is arguably the most important service to be provided by a frame description system (see [4] for evidence of this). If this service is to be provided in a reasonable fashion to the rest of a knowledge-based system, then these relations must be de termined in a timely way. Thus, while expressive power is typically the most immediate concern of representation language designers, it cannot be &dressed without simultaneous consideration of its computational implications.

Computational cost concomitant with expressive power has been treated in depth in the arena of formal languages like that of firstorder logic. However, while frames have been used extensively in AI systems, and have been found expressively adequate for some tasks, their instrinsic computational properties have not been accounted for.
We have explored the complexity of determining subsumption in a family of frame-based description languages, and have found that it is in fact remarkably sensitive to what seem to be small changes in the representational vocabulary. In order to illustrate this surprisingly touchy tradeoff, we here examine in detail a representative frame language and a simple variant.

Let us consider a simple description language, 3X!, with two major syntactic types-concepts and roles. These will correspond to the typ ically less well-defined notions of “frame” and “slot”. Intuitively, we think of concepts as representing individuals, and roles as representing relations between individuals. 3C has the following grammar:  ::= (atom) ] (AHD (conceptl). . . (concept,)) 1 (ALL (role) (concept)) ] (SOMEI(role))  While the linear syntax is a bit unorthodox, Z is actually a distillation of the operators in typical frame languages. Atoms are the names of primitive (undefined) concepts. ANDconstructions represent conjoined concepts, so for example, (AND adult male person) would represent the concept of something that was at the same time an adult,  with multiple fillers might translate into a “who (or that) has n” construct (“who has at least 3 enrolled-courrtr”), possibly followed by an “each of which” qualiEcation (“each of which is a gradu&tr-eourrr"). Finally, a slot with multiple filters, but with no number restriction specified, would translate simply into an “each (or all) of whose” qualification (“all of whose daulhtrr6 are doctorr").

a male, and a person (i.e., a man). In general, z is an (AHDcl c2 . . .
cn) iff z is a cl and a c2 and .. . and a cm. This allows us to put severa1 properties (i.e.s,uperconcepts or slot restrictions) together in the definition of a concept. The ALL construct provides a value- or type restriction on the fillers of a role (z is an (ALL r c) iff each r of z is a c).
Thus (ALL child doctor) corresponds to the concept of something all of whose children are doctors. It is a way to restrict the value of a slot at a frame. The SOMEoperator guarantees that there will be a least one filler of the role named (z is a (SOMEt) iff z has at least one r). For instance, (AND person (SOME child)) would represent the concept of a parent. This is a way to introduce a slot at a frame.
Note that in the more common frame languages, the ALL and SOMEare not broken out as separate operators, but instead, either every slot restriction is considered to have both universal and existential import, or exclusively one or the other (or it may even be left unspecified).’ Our language allows for arbitrary numbers 01 role fillers, and allows the SOMEand ALL restrictions to be specified independently. Finally, the RESTR construct accounts for rolesconstrained by the types of their fillers, e.g., (RESTB child male) for a child who is a male, that is, a son (in general, y is a @SIR r c) of z iff y is an r of z and y is a c).
It is simple to map more standard notations into our frame language. One reading of the the frame used aa the first example in this paper is “person with at least one child, and each of whose sons is a lawyer and each of whose daughters is a doctor”. In 3L1, that reading would bc represented this way:  (AND person (SOME child) (ALL (RESTR child (ALL (RESTR child  We now briefly define a straightforward extensional semantics for 3Z, the intent of which is to provide a precise definition of subsump tion. This will be done as follows: imagine that associated with each description is the set of individuals (individuals for concepts, pairs of individuals for roles) it describes. Call that set the ezlension of the description. Notice that by virtue of the structure of descriptions, their extensions are not independent (for example, the extension of (AND cl ~2) should be the intersection of those of cl and ~2). In general, the structures of two descriptions can imply that the extension of one is always a superset of the extension of the other. In that case, we will say that t!le first subsumes the second (so, in the caSe just mentioned, cl would be said to subsume (ANDcl c2)).
Let D be any set and & be any function from concepts to subsets of D and roles to subsets of the Cartesian product, D x D. So E [c] E D for any concept c, and &[r] C D x D foranyroler.

Finally, for any two concepts cl and cp, we can say that cl is subsumed by c2 if and only if for any set D and any extension function E  ‘See [s] for some further discussion of the import of languages like KRL. As it turns out, the unversal/existential distinction is most often moot, because most frame languages allow only single-valued slots. Thus the slot’s meaning is reduced to a simple predication on a single-valued function (e.g., the slot/value pair 6nr:iBt666r means inteoerfaaelzl)).

over D, E[cl] C C[cz]. Th a t is, one concept concept when all instances of the first-in stances of the second. From a semantic dictates a kind of necessary set inclusion.

is subsumed by a second all extensions-are also inpoint of view, subsumption  of how this is an appropriate view of subsumg two descriptions in 3l, dl and dz, where dl sub A proof that dl subsumes dz, based on our formal definition of subsumpt,ion, might go as follows. Let D be any set, E any extension function over D, and z any element of f[dz]. By applying (1) above to d2 twice, we know that z E E[person] and that by (2), if (z,y) E E[child], then y E &[rich], and so by (4), (z,y) E l[(RE!XR child rich)]. Also, by (2), if (z, y) E E[(RESIR child rich)], then, by (1) and the definition of dz, y E C[doctor]. Putting these two together, we have that if (z,y) E flchild], then y E f [doctor]. Since z E f [person], then by (2) and (l), z E f[d;]. To summarize, because all of the children of a d2 are rich, and each of a dz’s rich children is a certain kind of doctor, then all of d2’s children are doctors. Because any d2 is also a person, the description dz is subsumed by the description dl.

Given a precise definition of subsumption, we can now consider algorithms for calculating subsumption between descriptions. Intuitively, this seems to present no real problems. To determine if a subsumes b, what we have to do is make sure that each component of a is “implied” by some component (or components) of b, exactly the way we just determined that dl subsumed dp. Moreover, the type of “implication” we need should be fairly simple since 3L has neither a negation nor a disjunction operator.

Unfortunately, such intuitions can be nastily out of line. In particular, let us consider a slight variant of 3L-call it 3L3-. 3L%- include9 all of 31 except for the RESTR operator. On the surface, the difference between 3l- and 3f seems expressively minor. But it turns out that it is computationally very significant. In particular, we have found an O(n*) algorithm for determining subsumption in 3l-, but have proven that the same problem for 3C is intractable, In the rest of this section, we sketch the form of our algorithm for 3f- and the proof that subsumption for 3l is as hard as testing for propositional tautologies, and therefore most likely unsolvable in polynomial time.
Subsumption Algorithm for 3f -: SUBS?[a,bj  a is now (ANDal . . . a,) and b is (ANDbl . . . b,), offfor each ai,  T[Pl VP2 v... VP,V-Pn+l V-rP”+:!V...V-Pm] (AND (ALL (RESTR R pl) A) . . .
(ALL (RESTR R p,,) A)  n[al hazh...hak] = (AND (ALL (RESIR S (SOME(RESTR R A))) B) (ALL (RESTR S +q]) B) . . .
(ALL (RESTR S +k]) B))  A proof that this mapping has the desired property is given in [S].
What this means is that an algorithm for subsumption can be used to answer questions of implication by first mapping the two sentences into descriptions in 3L and then seeing if one is subsumed by the other.
Moreover, because r can be calculated efficiently, any good algorithm for subsumption becomes a good one for implication.

The key observation here, however, is that there can be no good algorithm for implication. To see this, note that a sentence implies (ph -p) just in case it is not satisfiable. But determining the satisfiablity of a sentence in this form is NP-complete [5]. Therefore, a special case of the implication problem (where the second argument is (p A -p)) is the complement of an NP-complete one and so is a co-NP-complete problem. The correspondence between implication and subsumption, then, leads to the following:  The lesson here is clear-there seems to be a sudden and unexpected “computational cliff” encountered when even a slight change of a certain sort is made to a representation language.6 We are actively engaged in examining other dimensions of representation languages, in an effort to understand exactly what aspect of the representation is responsible for the computational precipice.

Besides warning us to be careful in selecting operators for a knowledge representation language, the tradeo5 between expressiveness and computational tractability serves as admonition against blind trust of our intuitions. The change from 3l%- to 3lf seemed simple enough, yet caused subsumption to become intractable. Other generalizations to 3lI:- that we have considered appear at least as dangerous, and yet in the end prove no problem at all. For example, we have examined a variant of 31- that generalizes the SOMEoperator to be an AI-LEAST operator, whereby we can require any number of fillers for a certain role. Further, we might add an operator called ROLE-CHAIN, that allows us to string roles together. Given these two new operators, we  “More precisely, the cc+NP-complete problems are strongly believed to be unsolvable in polynomial time.

61t should be emphasized that the question of tractability is a matter of expressiveness, and not of the particular description language. Here we have used a simple language to illustrate our point, but the tradeoff affects a.ny language that allows the same distinctions to be made.

Remarkably enough, even the simultaneous addition of both of these operators to 3l- does not cause subsumption to fall off of the computational cliff (81.
This line of research probably has a long way to go before the definitive story is told on the complexity of computing with AI description languages. However, we seem to have made a significant start in formally analyzing an essential frame language and its variants. Further, the methodology itself is an important factor. Crucially, the notion of subsumption in this account is driven from the semantics, so that there is always a measure of correctness for the algorithms we design to compute it. Thus, we will not fall prey to one problem that has plagued work in this area since its inception-the excuse that what subsumption (or any other important relation) means is “what the code does to compute it”. In fact, our approach so well defines the problem that we can find cases where it is provable that no algorithm of a certain sort can be designed.

This research was done in the context of the KRYPTON and as a result, benefited greatly from discussions with Richard Peter Pate!-Schneider, and Victoria Pigman.

Cook, S. A., “The Complexity Proc. 3rd Ann. ACM Symposium York: Association for Computing  of Theorem-Proving Procedures.” on Theory of Computing. New Machinery, 1971, pp. 151-158.

H. J., and R. J. Brachman, “Some of Subsumption in Frame-Based In preparation.