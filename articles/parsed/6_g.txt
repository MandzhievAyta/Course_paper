If intelligent agents are to act rationally, they be able to reason about the effects of their actions.
thermore, if the environment is dynamic, or includes agcmls, they need to reason about the interaction their actions and events in the environment, and able to bynchronize their activities to achieve their  hlost previous work in action planning has assumed a :,iIlglc agrnt acting in a static world. In such cases, it is sufficicut to represent actions as state change operators (e.g., [-I], 191). llowcvcr, as in the study of the semantics of programming languages, the interpretation of actions as functions or relations breaks down when multiple actions can be performed concurrently. The problem is that, to reason about the effects of concurrent actions, we need to know hog t hc act ions are performed, not just their final effects.

Some attempts have recently been made to provide a better underlying theory for actions. McDermott [lo] considers an action or event to be a set of sequences of states, and describes a temporal logic for reasoning about such actions and events. Allen [l] also considers an action to be a set of sequences of states, and specifies an action by giving the relationships among the intervals over which the action’s condibions and effects are assumed to hold. However, while it is possible to state arbitrary properties of actions and events, it is not obvious how one could use these logics  In a previous paper [5], we proposed a method for forming synchronized plans that allowed multiple agents to achieve mult.iplc goals, given a simple model of the manner in which the actions of one agent interact with those of other agents. In this paper, we propose a more general model of action, and show how it can be used in the synthesis or vcrificat ion of multiagent plans and concurrent programs.

Agents are machines or beings that act in a world. We distinguish between the internal workings of an agent and the external world that affects, and is affected by, that agent. All bhat can be observed is the external world. At any given instant, the world is in a particular world state, \vhich can be described by specifying conditions that, are true of that state.

Let us assume that the world develops through time by undergoing discrete changes of state. Some of these changes are caused by agents acting in the world; others occur “naturally,” pc)rhaps as a result of previous state changes. Actions and events arc considered to be composed of primiti\-e objects called atomic fmnsitions. An atomic transition is a relation on the set of world states. Any sequence of states resulting from the application of some specified atomic transitions will be called an event. Note that we do not rcquirc that atomic transitions be deterministic, but we do require that t,hey terminate.

An action is a class of events; viewed intuitively, those that result from the activity of some agent or agents in accomplishing some goal (including the achievement of desired conditions, the maint,enance of desired invariants, the prevention of other events, etc.)  ‘Allen [2] proposes a method for forming multiagent plans that is based on his representation of actions. However, he does not use the temporal logic directly, and actions are restricted to a particularly simple form (e.g., they do not include conditionals).

Usually we do not have access to this internal structure.
However, since we are interested only in the observable behavior of the agent, we do not need to know the internal processes that govern the agent’s actions. Thus, to reason about how the agent acts in the world and how these actions interact with events in the world, we need only an abstract model that explains the observable behavior of the agent.

We shall specify the class of possible and observable behaviors of an agent when it performs an action by means of a device called a process model. A process model consists of a number of internal states called control points. At any moment in time, execution can be at any one of these control points. Associated with each control point is a correctness condition that specifies the allowable states of the world at that control point.

The manner in which the device performs an action is described by a partial function, called the proceaa control function, which, for a given control point and given atomic transition, determines the next control point. A process model can thus be viewed as a finite-state transition graph whose nodes are control points and whose arcs are labeled with atomic transitions.

A process model for an action stands in the same relationship to the internal workings of an agent and events in the external world as a grammar for a natural language bears to the internal linguistic structures of a speaker and the language that is spoken. That is, it models the observable behavior of t.he agent, without our claiming that the agent actually possesses or uses such a model to generate behaviors.

A process model describes an action Formally, a process model is a seven-tuple A = (S, F, C, 6, f, q, CF) where  l P : C - P associates subsets point; values of this function conditions  In general, 6 is a partial function. If for a control c and atomic transition tr, (c, tr) is in the domain say that tr is applicable at c.

We are now in a position to define the execution of a process model. Let A be a process model as defined above.
We first define a state of execution of A to be a pair (u, c), where * c E C and u E S’. We say that a state of execution  In (I) we say that the transition is effected by the agent executing A, while in (2) we say that the transition is effected by the environment.

We now define for el and e2 defined say that el successfully s2 e P( c2), execution  a restriction on the relation bA. If, above, el bA e2 and 92 E P(Q), we generates e2, denoted el =+A e2. If is said to fail.

Let =s> denote the reflexive transitive relation *.Q. Then the action generated is defined to be  element of Q# is called a behavior o itself is the set of all behaviors of A.

Viewed intuitively, the device works as follows. If it is at control point cl and the world is in a state si satisfying the correctness condition P(Q), the device can pass to control point c2 and t.he world to state 52 as long as there exists an applicable atomic transition tr between states a1 and s2 and S(Cl) tr) = cg. Alternatively, the device can stay at control point cl and some transition or event occur in the world (perhaps resulting from the action of some other agent). In either case, for the execution to be successful (not to fail), the new world state must satisfy the correctness condition at c2, i.e., s2 must be an element of P(Q).

In performing t’he action cr, the device starts point cf. The action terminates when the device CF. Given an initial state of the world 8, various of world states can be generated by the process passes from the initial to the final control point.
all such sequences constitute the action itself.

at control reaches sequences model a8 it The set of  This is the same general view of action as presented by Allen [I] and McDermott [lo]. However, our theory differs in t,hat it allows us to distinguish between transitions effected by the agent and those effected by the external world. This is particularly important in the synthesis and verification of multiagent plans and concurrent programs (e-g-, PI)* Note that we do not require that a state satisfying the correctness condition at a control point be in the domain of some atomic transition applicable at that control point.
Thus, it is possible for the agent to arrive at an intermediate control point and not to be able to immediately effect a further transition. In such cases, the environment must change before the action can progress. This could occur, for example, if an agent nailing two boards together expected another to help by holding the boards. Only when the “holder” (who is part of the environment) has provided the necessary assistance (and moved the state of the world into  the domain of an applicable proceed with the action.

Neither do we require that an atomic transition performed by an agent always be successful i.e., the transition could sometimes leave the agent in a state that violated the current correctness condition. A process model that allowed such transitions could sometimes fail. In most cases, this is undesirable (though it may be unavoidable), and for the rest of the paper we will assume that this cannot happen. That is, we will assume that only the environment (or another agent) can cause an action to fail.

It should also be noted that the correctness conditions say nothing about termination - it may be that an action never reaches completion. This can be the case if the action is waiting for a condition to be satisfied by the environment (so that a transition can be effected), it loops forever, the environment is unfair (i.e., does not give the action chance to execute).

In many cases, we wish to model actions that proceed at an undetermined rate and fail if they are ever forced to suspend execution. For example, it is difficult to hit a golf ball if the environment is allowed to remove and replace the ball at arbitrary times during one’s swing. Such uninterruptable actions require that, for any control point c, any state that satisfies the correctness condition at c also be in the domain of some atomic transition applicable at c.

A plan or program for an agent is a syntactic object consisting of primitive operations combined by constructions that represent sequencing, nondeterministic choice, iteration, forks and joins, etc. If we intend the denotations of such plans to be process models, we need some means combining the latter in a way that reflects the composition operators in plans.

Of special int,erest, and indeed the motivation the model presented here, is the parallel-composition at,or. We define this below.

Let Al = (S, FI : C1, &, PI, cfl, cF1) and A2 = (S, F21 G, 6211’2, c12, cF2) be two process models for actions o1 and a=, respectively. Then we define a process model representing the parallel composition of Al and AZ, denoted Al 11A*, to be the process model (S, F, C, 6, P, CI, CF), where  l For all cl E C, and c2 E C2, pk, c2)) = Pl(cl) n p2(c2)  to show that the action a generated (1: n y 1 I E CQ and y E ~2).

Note that the projection of S onto CI and C2 gives exactly the control function for the component process models. At any moment, each component is at one of its own control points; the pair of control points, taken together, represents the current control point of the parallel process.
Furthermore, the behaviors generated by these two processes running in parallel are also generated by each of them running separately. This means that any property of the behaviors of the independent processes can be used to determine the effect of the actions running in parallel. This is particularly important in providing a compositional logic for reasoning about such actions (see [3]).

The above model of parallel execution is an interleaving model. Such a model is adequate for representing almost all concurrent systems. The reason is that, in almost all cases, it is possible to decompose actions into more and more atomic t,ransitions until the interleaving of transitions models the system’s concurrency accurately. The nondeterministic form of the interleaving means that we make no assumption about the relative speeds of the actions. We can also define a parallel composition operator that is based on communication models of parallel action, in which communication acts are allowed to t,ake place simultaneously. This, together wit,h other composition operators, is described by me elsewhere [6].

In plan synthesis and verification it is important to be able to determine whether or not concurrent actions interfere with one another. In the previous section we defined what it meant for two actions (strictly speaking, process models) to run in parallel. Now we have to determine whether execution of such a parallel process model could fail because of interaction between the two component processes.

Consider, then, two actions a and p generated by process models A and 8, respectively. The process model corresponding to these actions being performed in parallel is A /) 8. In analysing t,his model, however, we will view it in terms of its two component process models (i.e., A and 8).

Assume that we are at control points cl in A and c2 in 8, and that tr is an atomic transition applicable at ~2. Clearly, if the process has not failed, the current world state must satisfy both P(cl) and P(c2). Now assume that process B continues by executing the atomic transition tr. This transition will take us to a new world state, while leaving us at the same control point within A. From A’s point of view; this new state must still satisfy the condition P(cl).
Thus, we can conclude that the transition tr executed at control point c2 will not cause A to fail at cl if the following condition holds:  We say that the transition tr at control point ~2 does not , interfere with A if the above condition holds at all control points in A, i.e., for all correctness conditions associated with A.

We are now in a position to define freedom from interference. A set of process models Al,. . . A, is said to be interference-free s if the following holds for each process Ai: for all control points c in A; and all transitions tr applicable at c and for all j, j # i, tr at c does not interfere with Aj.

Thus, if some set of actions is interference-free, none can be caused to fail because of interaction with the others. Of course, any of the actions could fail as a result of interaction with the environment.

From this it follows that, for ascertaining freedom interference, it is sufficient to represent the functioning a device by  transitions restricted to the correctof the node from which they exit.

Knowledge of a process model’s structure (i.e., the process control function), is unnecessary for this purpose. In a distributed system, this means that an agent need only make known the foregoing information to enable it to interact safely with other agents. We call such information a reduced specification of the action.

Let us consider the following example. Blocks A, B and C are currently on the floor. We wish to get blocks A and B on a table, and block C on a shelf, and have two agents, X and Y, for achieving this goal. Agent X has not got access to block B, but can place block A on the table and block C on the shelf. He therefore forms a plan for doing so. Agent Y cannot reach block A, but is happy to help with block B. Unfortunately, in doing so, he insists that the floor be clear of block C at the completion of his action.

The plans for agent X and Y are given below. The correctness conditions at each control point in the plans are shown in braces, “{” and “}“. The “if” statement is assumed to be realized by two atomic transitions. The first of these is applicable when block C is on the floor, and results in block C being placed on the table, The second is applicable when block C is not on the floor, and does nothing (i.e., is a no-op). The process models corresponding to these plans should be self-evident.

definition of the notion “interference-free” generalizes to arbitransitions that used by Owicki and Gries[llj for verifying conprograms. Synchronization primitives have not been included but can be handled by conditional atomic transitions IS].

{(clear B) and (clear (puton B TABLE) {(on B TABLE) if (on C FLOOR)  and (clear C)} then (puton C TABLE) and not (on C FLOOR)}  It is clear from the definition given above that these actions are interference-free. However, they interact in quite a complex manner. In some circumstances, agent Y will put block C on the table, which would seem to suggest interference. Nevert,heless, interference freedom is assured because the only time that Y can do this is when it does not matter, i.e., before X has attempted to put C on the shelf. Note that if the test and action parts of the “if’ statement were separate atomic transitions, rat,her than a single one, then the actions would not be free from interference.

So far we have been interested solely in reasoning about possible interference among actions. For many applications, we may wish to reason more generally about actions.
One way to do this is to construct, a logic suitable for reasoning about process models and t’he behaviors they generate. That is, we let process models serve as interpretat,ions for plans or programs in the logic. An interesting compositional temporal logic has been developed by Barringer et al [3]. Because it is compositZional, process models provide a natural interpretation for the logic.

One may well ask what role process models play, given that the only observables are sequences of world states and that a suitable temporal logic, per se, is adequate for describing such sequences. However, in planning to achieve some goal, or synthesizing a program, we are required to do more than just describe an action in an arbitrary way - we must. somehow form an object that allows us to choose our nest action (or atomic t#ransition) purely on the basis of the current execution state, without any need for further reasoning.

We could do this by producing a temporal assertion about the action from which, at any moment of time, we could directly ascertain the next operation to perform (e.g., a formula consisting of appropriat,ely nested “next” operators). Thus, in a pure t,emporal logic formalism, plan synthesis would require finding an approriately structured temporal formula from which it was possible to deduce satisfaction of the plan specificabion. However, instead of viewing planning syntactically (i.e., as finding temporal formulas with certain structural properties), it is preferable, and more intuitive, to have a model (such as a process model) that explicitly represents the denotation of a plan or program (see [6]).

Process models serve other purposes interference freedom is easily determined, model, but it is less clear how this could  ficiently, given a general specification in a temporal logic.
Even so, one would need to construct an appropriate process model first (or its syntactic equivalent in a temporal logic), as the implementation of the specifications might make it necessary to place additional constraints upon the plan.

In combination with a temporal logic such as suggested above, the proposed theory of action provides a semantic basis for commonsense reasoning and natural-language understanding. Process models are more general than previously proposed models (e.g., [7]), particularly in the way they allow parallel composition. They can represent most actions describable in English, including those that are problematic when a&ions are viewed as simple state-change op erators, such as “walking to the store while juggling three balls” [I], “running around a track three times” [lo], or “balancing a ball” (which requires a very complex process model despite the apparent simplicity of its temporal specification). The theory also allows one to make sense of such notions as “sameness” of actions, incomplete actions (like an interrupted painting of a picture) and other important issues in natural-language understanding and commonsense reasoning.

Process models are also suitable for representing most programming constructs, including sequencing, nondeterministic choice (including conditionals) and iteration. Parallelism can also be represented, using either an interleaving model, as described in section 4, or a communication model.
The model used by Owicki and Gries [1 l] to describe the semantics of concurrent programs can be considered a special case of that proposed herein.

A nascent theory of action suitable for reasoning about interaction in multiagent or dynamically changing environments has been presented. More general than previous theories of action, this theory provides a semantics for action statements in both natural and programming languages.

The theory is based on a device called a process model, which is used to represent the observable behavior of an agent in performing an action. It was shown how this model can be utilized for reasoning about multiagent plans and concurrent programs. In particular, a parallel-composition operator was defined, and conditions for determining freedom from interference for concurrent actions were derived.
The use of process models as interpretations of temporal logics suitable for reasoning about plans and programs was also indicated.

hy, J., “Programs with Znformntiorl !‘rocessing Canhridge, hlassachusetts)  hlcl)erniott, D., “A l’emporal about Plans and I’rocesscs,“ Report 196, Yale University